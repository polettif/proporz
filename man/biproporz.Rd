% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/biproportional.R
\name{biproporz}
\alias{biproporz}
\title{Biproportional apportionment}
\usage{
biproporz(
  votes_matrix,
  district_seats,
  quorum_districts = 0,
  quorum_total = 0,
  use_list_votes = TRUE,
  method = "round"
)
}
\arguments{
\item{votes_matrix}{Vote count matrix with votes by party in rows
and votes by district in columns}

\item{district_seats}{Vector defining the number of seats per district.
Must be the same length as ncol(votes_matrix). If the
number of seats per district should be assigned
according to the number of votes (not the general use
case), a single number for the total number of seats
can be used.}

\item{quorum_districts}{Vote threshold a party must reach in \emph{at least}
one district. Used as quota of total votes within a
district if less than 1 otherwise as number of votes.}

\item{quorum_total}{Vote threshold a party must reach for all votes cast.
Used as quota of total votes if less than 1 otherwise
as number of votes.}

\item{use_list_votes}{By default (TRUE) it's assumed that each voter in a
district has as many votes as there are seats in a
district. Set to FALSE if \code{votes_matrix} shows the
number of voters.}

\item{method}{Defines how seats in upper and lower apportionment are
assigned. The default "round" for the Sainte-LaguÃ«/Webster
method is the standard for biproportional apportionment. See
\link{proporz} for a list of available methods. For a different
method for upper and lower apportionment use a vector with two
entries. It is also possible to provide a function that works
like base::round(x) (i.e. can handle a matrix).}
}
\description{
Method to proportionally allocate seatsamong parties (or lists) and
districts (or entities, regions).
}
\details{
Each party nominates a candidate list for every district. The voters vote
for the parties of their district. The seat allocation is calculated in two
steps:
\enumerate{
\item In the so called \emph{upper apportionment} the number of seats for
   each party (over all districts) is determined. Normally, the number of
   seats for each region are defined before the election and are independent
   of the vote counts.
\item In the so called \emph{lower apportionment} the seats are distributed
   to the regional party list respecting the results from the upper
   apportionment.
}

Parties failing to reach at least one quorum cannot get seats.
}
\examples{
votes_df = unique(zug2018[c("list_id", "entity_id", "list_votes")])
votes_matrix = pivot_to_matrix(votes_df)
votes_matrix
#>        entity_id
#> list_id  1701 1702 1703 1704 1705 1706 1707 1708 1709 1710  1711
#>       1  2993    0    0    0    0    0    0    0    0    0     0
#>       2  8108 4687 1584  531  279  477 2363 3860 1481   91 22023
#>       3 19389 9334 4807 1946  396 2844 3523 4702 3310  812 21343
#>       4 14814 6691 4005  826  379 1654 2842 2624 2713  461 33789
#>       5  4486 2270  621  198    0  361  728  465  925    0 10131
#>       6 15695 4705 1750   84    0   51  627 1106 1563  302 21794
#>       7 21298 8178 2875 1336  399 1450 3715 2610 4063  344 26798

distr_df = unique(zug2018[c("entity_id", "election_mandates")])
district_seats = setNames(distr_df$election_mandates, distr_df$entity_id)
district_seats
#> 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711
#>   15   10    6    3    2    4    7    6    6    2   19

biproportional(votes_matrix, district_seats, 0.05, 0.03)
#>         entity_id
#> list_id 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711
#>       1    0    0    0    0    0    0    0    0    0    0    0
#>       2    2    1    1    0    0    0    1    2    1    0    3
#>       3    3    3    2    1    1    2    2    2    1    1    3
#>       4    2    2    1    1    0    1    2    1    1    1    5
#>       5    1    1    0    0    0    0    0    0    0    0    2
#>       6    3    1    1    0    0    0    0    0    1    0    3
#>       7    4    2    1    1    1    1    2    1    2    0    3

# Different method for upper apportionment
# and using number of voters instead of list votes
f19_matrix = pivot_to_matrix(finland2019$votes_df)
f19_distr_seats = setNames(
    finland2019$district_seats_df$election_mandates,
    finland2019$district_seats_df$entity_id)

biproportional(f19_matrix, f19_distr_seats,
               use_list_votes = FALSE,
               method = c("floor", "round"))

}
\seealso{
\link{pukelsheim} for usage with data frames.
         \code{\link{divisors}} to access the divisors
}

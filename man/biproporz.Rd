% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/biproportional.R
\name{biproporz}
\alias{biproporz}
\title{Biproportional apportionment}
\usage{
biproporz(
  votes_matrix,
  district_seats,
  quorum,
  use_list_votes = TRUE,
  method = "round"
)
}
\arguments{
\item{votes_matrix}{Vote count matrix with votes by party in rows
and votes by district in columns}

\item{district_seats}{Vector defining the number of seats per district.
Must be the same length as \code{ncol(votes_matrix)}.
If the number of seats per district should be assigned
according to the number of votes (not the general use
case), a single number for the total number of seats
can be used.}

\item{quorum}{Optional list of functions which take the votes_matrix and
return a logical vector that denotes for each list/party
whether they reached the quorum (i.e. are eligible for seats).
The easiest way to do this is via \code{\link[=quorum_any]{quorum_any()}} or
\code{\link[=quorum_all]{quorum_all()}}, see examples. Alternatively you can pass a
precalculated logical vector. No quorum is applied if parameter
is missing or NULL.}

\item{use_list_votes}{By default (\code{TRUE}) it's assumed that each voter in a
district has as many votes as there are seats in a
district. Set to FALSE if \code{votes_matrix} shows the
number of voters.}

\item{method}{Defines how seats in upper and lower apportionment are
assigned. The default "round" for the Sainte-Laguë/Webster
method is the standard for biproportional apportionment. See
\link{proporz} for a list of available methods. For a different
method for upper and lower apportionment use a vector with two
entries. It is also possible to provide a function that works
like \code{base::round(x)} (i.e. can handle a matrix).}
}
\value{
Matrix with the same dimension as \code{votes_matrix} containing
the number of seats
}
\description{
Method to proportionally allocate seats among parties (or lists) and
districts (or entities, regions), thus bi-proportional.
}
\details{
Each party nominates a candidate list for every district. The voters vote
for the parties of their district. The seat allocation is calculated in two
steps:
\enumerate{
\item In the so called \emph{upper apportionment} the number of seats for
each party (over all districts) is determined. Normally, the number of
seats for each region are defined before the election and are independent
of the vote counts.
\item In the so called \emph{lower apportionment} the seats are distributed
to the regional party list respecting the results from the upper
apportionment.
}

Parties failing to reach quorums cannot get seats.
}
\note{
The iterative process in the lower apportionment is only guaranteed
to terminate with the Sainte-Laguë/Webster method.
}
\examples{
votes_df = unique(zug2018[c("list_id", "entity_id", "list_votes")])
votes_matrix = pivot_to_matrix(votes_df)

distr_df = unique(zug2018[c("entity_id", "election_mandates")])
district_seats = setNames(distr_df$election_mandates, distr_df$entity_id)

biproporz(votes_matrix, district_seats, quorum_any(0.05, 0.03))

# calculate quorum beforehand (leads to the same result as above)
q1 = reached_quorum_any_district(votes_matrix, 0.05)
q2 = reached_quorum_total(votes_matrix, 0.03)
reached_quorum = q1 | q2

biproporz(votes_matrix, district_seats, reached_quorum)

# Different method for upper apportionment
# and using number of voters instead of list votes
f19_matrix = pivot_to_matrix(finland2019$votes_df)
f19_distr_seats = setNames(
    finland2019$district_seats_df$election_mandates,
    finland2019$district_seats_df$entity_id)

f19_seats = biproporz(f19_matrix, f19_distr_seats,
               use_list_votes = FALSE,
               method = c("floor", "round"))

f19_seats[rowSums(f19_seats) > 0,]

}
\references{
Gaffke, Norbert; Pukelsheim, Friedrich (2008): Divisor methods
for proportional representation systems: An optimization approach
to vector and matrix apportionment problems. Mathematical Social
Sciences, 56 (2), 166–184.
}
\seealso{
\code{\link[=pukelsheim]{pukelsheim()}} for usage with data frames.
\code{\link[=get_divisors]{get_divisors()}} to access the divisors
}

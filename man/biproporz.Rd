% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/biproportional.R
\name{biproporz}
\alias{biproporz}
\title{Biproportional apportionment}
\usage{
biproporz(
  votes_matrix,
  district_seats,
  quorum,
  use_list_votes = TRUE,
  method = "round"
)
}
\arguments{
\item{votes_matrix}{Vote count matrix with votes by party in rows
and votes by district in columns}

\item{district_seats}{Vector defining the number of seats per district.
Must be the same length as \code{ncol(votes_matrix)}.
If the number of seats per district should be assigned
according to the number of votes (not the general use
case), a single number for the total number of seats
can be used.}

\item{quorum}{Optional list of functions which take the votes_matrix and
return a logical vector that denotes for each list/party
whether they reached the quorum (i.e. are eligible for seats).
The easiest way to do this is via \code{\link[=quorum_any]{quorum_any()}} or
\code{\link[=quorum_all]{quorum_all()}}, see examples. Alternatively you can pass a
precalculated logical vector. No quorum is applied if parameter
is missing or NULL.}

\item{use_list_votes}{By default (\code{TRUE}) it's assumed that each voter in a
district has as many votes as there are seats in a
district. Set to FALSE if \code{votes_matrix} shows the
number of voters.}

\item{method}{Defines how seats in upper and lower apportionment are
assigned. The default "round" for the Sainte-Laguë/Webster
method is the standard for biproportional apportionment. See
\link{proporz} for a list of available methods. For a different
method for upper and lower apportionment use a vector with two
entries. It is also possible to provide a function that works
like \code{base::round(x)} (i.e. can handle a matrix).}
}
\value{
Matrix with the same dimension as \code{votes_matrix} containing
the number of seats
}
\description{
Method to proportionally allocate seats among parties (or lists) and
districts (or entities, regions), thus bi-proportional.
}
\details{
Each party nominates a candidate list for every district. The voters vote
for the parties of their district. The seat allocation is calculated in two
steps:
\enumerate{
\item In the so called \emph{upper apportionment} the number of seats for
each party (over all districts) is determined. Normally, the number of
seats for each region are defined before the election and are independent
of the vote counts.
\item In the so called \emph{lower apportionment} the seats are distributed
to the regional party list respecting the results from the upper
apportionment.
}

Parties failing to reach quorums cannot get seats.
}
\note{
The iterative process in the lower apportionment is only guaranteed to terminate
with Sainte-Laguë/Webster method.
}
\examples{
votes_df = unique(zug2018[c("list_id", "entity_id", "list_votes")])
votes_matrix = pivot_to_matrix(votes_df)
votes_matrix
#>        entity_id
#> list_id  1701 1702 1703 1704 1705 1706 1707 1708 1709 1710  1711
#>       1  2993    0    0    0    0    0    0    0    0    0     0
#>       2  8108 4687 1584  531  279  477 2363 3860 1481   91 22023
#>       3 19389 9334 4807 1946  396 2844 3523 4702 3310  812 21343
#>       4 14814 6691 4005  826  379 1654 2842 2624 2713  461 33789
#>       5  4486 2270  621  198    0  361  728  465  925    0 10131
#>       6 15695 4705 1750   84    0   51  627 1106 1563  302 21794
#>       7 21298 8178 2875 1336  399 1450 3715 2610 4063  344 26798

distr_df = unique(zug2018[c("entity_id", "election_mandates")])
district_seats = setNames(distr_df$election_mandates, distr_df$entity_id)
district_seats
#> 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711
#>   15   10    6    3    2    4    7    6    6    2   19

biproporz(votes_matrix, district_seats, quorum_any(0.05, 0.03))
#>         entity_id
#> list_id 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711
#>       1    0    0    0    0    0    0    0    0    0    0    0
#>       2    2    1    1    0    0    0    1    2    1    0    3
#>       3    3    3    2    1    1    2    2    2    1    1    3
#>       4    2    2    1    1    0    1    2    1    1    1    5
#>       5    1    1    0    0    0    0    0    0    0    0    2
#>       6    3    1    1    0    0    0    0    0    1    0    3
#>       7    4    2    1    1    1    1    2    1    2    0    3

# calculate quorum beforehand (leads to the same result as above)
q1 = reached_quorum_any_district(votes_matrix, 0.05)
q2 = reached_quorum_total(votes_matrix, 0.03)
reached_quorum = q1 | q2
reached_quorum
#>     1     2     3     4     5     6     7
#> FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE

biproporz(votes_matrix, district_seats, reached_quorum)

# Different method for upper apportionment
# and using number of voters instead of list votes
f19_matrix = pivot_to_matrix(finland2019$votes_df)
f19_distr_seats = setNames(
    finland2019$district_seats_df$election_mandates,
    finland2019$district_seats_df$entity_id)

f19_seats = biproporz(f19_matrix, f19_distr_seats,
               use_list_votes = FALSE,
               method = c("floor", "round"))

f19_seats[rowSums(f19_seats) > 0,]
#>        entity_id
#> list_id HAEM HEL KAA KES LAP OUL PIR SAT SKA UUS VAA VAR
#> KD      1   0   1   1   0   1   1   0   1   1   1   0
#> KESK    1   1   3   2   2   6   2   1   3   2   3   2
#> KOK     3   5   3   1   1   2   4   1   2   7   2   4
#> Nyt     0   0   0   0   0   0   0   0   0   1   0   0
#> NYT     0   1   0   0   0   0   0   0   0   0   0   0
#> PIR     0   1   0   0   0   0   0   0   0   0   0   0
#> PS      3   3   3   2   1   4   3   2   3   6   3   3
#> RKP     0   1   0   0   0   0   0   0   0   4   3   1
#> SDP     4   3   4   2   1   2   4   2   3   7   2   3
#> SIN     0   0   0   0   0   0   0   0   1   1   0   0
#> VAS     1   2   1   1   1   2   2   1   1   2   1   2
#> VIHR    1   5   2   1   1   1   3   1   1   5   1   2


}
\seealso{
\code{\link[=pukelsheim]{pukelsheim()}} for usage with data frames.
\code{\link[=get_divisors]{get_divisors()}} to access the divisors
}

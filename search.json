[{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1) Introduction","title":"Apportionment scenarios","text":"vignette explores implementation different seat apportionment scenarios. generally two ways assign seats parliament: Either distribute seats within district independently distribute seats according vote share whole election region (e.g. national level). focus difference seat shares compared vote shares two approaches can produce.","code":""},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"setup-data","dir":"Articles","previous_headings":"","what":"2) Setup data","title":"Apportionment scenarios","text":"’ll mainly use data set 2019 Finnish parliamentary elections. finland2019 data set contains two data.frames: One number votes party, data.frame tells us many seats (election_mandates) district . make comparisons easier, ’ll use matrices instead data.frames. create votes_matrix given data.frame. also create named vector defines many seats district (district_seats). Note order district names district_seats columns votes_matrix differ. However, affect analysis access districts name (biproporz() way).","code":"library(proporz) str(finland2019) #> List of 2 #>  $ votes_df         :'data.frame':   229 obs. of  3 variables: #>   ..$ party_name   : chr [1:229] \"KOK\" \"SDP\" \"VIHR\" \"PS\" ... #>   ..$ district_name: chr [1:229] \"UUS\" \"UUS\" \"HEL\" \"UUS\" ... #>   ..$ votes        : int [1:229] 114243 97107 90662 86691 84141 78486 73626 66109 59722 55244 ... #>  $ district_seats_df:'data.frame':   12 obs. of  2 variables: #>   ..$ district_name: chr [1:12] \"HEL\" \"HÄM\" \"KAA\" \"KES\" ... #>   ..$ seats        : int [1:12] 22 14 17 10 7 18 19 8 15 36 ... votes_matrix = pivot_to_matrix(finland2019$votes_df) dim(votes_matrix) #> [1] 44 12  # Let's look at all parties with at least 10k votes knitr::kable(votes_matrix[rowSums(votes_matrix) > 10000,]) district_seats = finland2019$district_seats_df$seats names(district_seats) <- finland2019$district_seats_df$district_name district_seats #> HEL HÄM KAA KES LAP OUL PIR SAT SKA UUS VAA VAR  #>  22  14  17  10   7  18  19   8  15  36  16  17"},{"path":[]},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"function-to-distribute-seats-in-districts","dir":"Articles","previous_headings":"3) Distribute seats in every district independently","what":"3.1) Function to distribute seats in districts","title":"Apportionment scenarios","text":"Finland many jurisdictions, seats assigned district independently. biproportional apportionment among districts. following function, apply_proporz, calculates seat distribution district returns number seats per party district matrix. user can specify apportionment method quorum threshold.","code":"apply_proporz = function(votes_matrix, district_seats, method, quorum = 0) {     seats_matrix = votes_matrix     seats_matrix[] <- NA          # calculate proportional apportionment for each district (matrix column)     for(district in names(district_seats)) {         seats_matrix[,district] <- proporz(votes_matrix[,district],                                            district_seats[district],                                            quorum = quorum,                                            method = method)     }     return(seats_matrix) }"},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"actual-distribution-method-dhondt","dir":"Articles","previous_headings":"3) Distribute seats in every district independently","what":"3.2) Actual distribution method (D’Hondt)","title":"Apportionment scenarios","text":"Finnish election system uses D’Hondt method. ’ll calculate seat distribution baseline compare methods.","code":"bydistrict_v0 = apply_proporz(votes_matrix, district_seats, \"d'hondt\")  bydistrict_v0[rowSums(bydistrict_v0) > 0,] #>           district_name #> party_name HÄM HEL KAA KES LAP OUL PIR SAT SKA UUS VAA VAR #>       KD     1   0   0   0   0   0   1   0   1   1   1   0 #>       KESK   1   0   3   3   3   6   2   1   4   2   4   2 #>       KOK    3   6   3   1   1   2   4   1   2   9   2   4 #>       Nyt    0   0   0   0   0   0   0   0   0   1   0   0 #>       PS     3   3   4   2   1   4   4   2   3   6   3   4 #>       RKP    0   1   0   0   0   0   0   0   0   3   4   1 #>       SDP    4   3   5   2   1   2   5   3   3   7   2   3 #>       VAS    1   3   0   1   1   3   1   1   1   2   0   2 #>       VIHR   1   6   2   1   0   1   2   0   1   5   0   1"},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"alternative-methods","dir":"Articles","previous_headings":"3) Distribute seats in every district independently","what":"3.3) Alternative methods","title":"Apportionment scenarios","text":"’ll now look alternative apportionment methods. Sainte-Laguë method (standard rounding) example impartial party size. hand, Huntington–Hill method favors small parties. Generally, Huntington-Hill used quorum, otherwise parties zero votes get least one seat. example, quorum 3% votes district. Let’s compare seat distributions three methods. get number party seats national level rowSums. actual political analysis better left people familiar party system. However, fair say election system within districts significant impact number seats parliament. example, party seats changes Sainte-Laguë Huntington-Hill.","code":"bydistrict_v1 = apply_proporz(votes_matrix, district_seats,                                       method = \"sainte-lague\")  bydistrict_v2 = apply_proporz(votes_matrix, district_seats,                                       method = \"huntington-hill\",                                        quorum = 0.03) df_bydistrict = data.frame(     D.Hondt = rowSums(bydistrict_v0),     Sainte.Lague = rowSums(bydistrict_v1),     Huntington.Hill = rowSums(bydistrict_v2) )  # sort table by D'Hondt seats df_bydistrict <- df_bydistrict[order(df_bydistrict[[1]], decreasing = TRUE),]   # print parties with at least one seat knitr::kable(df_bydistrict[rowSums(df_bydistrict) > 0,])"},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"compare-seat-share-with-vote-share","dir":"Articles","previous_headings":"3) Distribute seats in every district independently","what":"3.4) Compare seat share with vote share","title":"Apportionment scenarios","text":"Let’s now compare vote shares national level seat share parliament. Since every entry votes_matrix one voter, can simply use row sums get vote shares. Otherwise, ’d weigh votes district according number seats. Since disproportionality analysis focus package, ’ll simply look difference shares actual distribution method. difference seat vote share varies among parties -1.5 +2.3 percentage points.","code":"vote_shares = rowSums(votes_matrix)/sum(votes_matrix)  shares = data.frame(     seats = rowSums(bydistrict_v0)/sum(district_seats),     votes = vote_shares  ) shares$difference <- shares$seats-shares$votes shares <- round(shares, 4)  # Only look at parties with at least 0.5 % of votes shares <- shares[shares$votes > 0.005,] shares <- shares[order(shares$difference),]  shares #>       seats  votes difference #> VIHR 0.1005 0.1154    -0.0149 #> KD   0.0251 0.0391    -0.0140 #> SIN  0.0000 0.0098    -0.0098 #> PIR  0.0000 0.0062    -0.0062 #> Nyt  0.0050 0.0081    -0.0030 #> VAS  0.0804 0.0821    -0.0017 #> RKP  0.0452 0.0455    -0.0003 #> KESK 0.1558 0.1381     0.0176 #> KOK  0.1910 0.1707     0.0202 #> PS   0.1960 0.1756     0.0204 #> SDP  0.2010 0.1781     0.0229"},{"path":[]},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"biproportional-party-seats","dir":"Articles","previous_headings":"4) Biproportional method","what":"4.1) Biproportional party seats","title":"Apportionment scenarios","text":"’ll now look biproportional apportionment whether better matches seat share national vote share. Keep mind simply using existing data sets biproporz really suitable modeling perspective. Vote distributions likely different , example, people know vote also counts national level smaller parties choose run districts. said, let’s assume data set properly modeled already. need consider voters Finland can vote one person district. can’t distribute many votes seats district among candidates/parties. Thus need use use_list_votes=FALSE parameter biproporz. Let’s now look difference vote seat share. can see, difference vote seat share ranges -0.5 +0.2 percentage point. Biproportional apportionment matches national vote share better apportionment district. expected however, since biproportional apportionment actually considers national vote share. Discussing pros cons regional representation compared priority national vote shares within scope vignette. following chunk shows seat changes.","code":"seats_biproportional = biproporz(votes_matrix,                                   district_seats,                                   use_list_votes = FALSE)  # show only parties with seats seats_biproportional[rowSums(seats_biproportional) > 0,] vote_shares = rowSums(votes_matrix)/sum(votes_matrix) seat_shares = rowSums(seats_biproportional)/sum(seats_biproportional)  range(vote_shares - seat_shares) #> [1] -0.005144852  0.002429257 seat_changes = seats_biproportional-bydistrict_v0  knitr::kable(seat_changes[rowSums(abs(seat_changes)) > 0,colSums(abs(seat_changes))>0])"},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"distribute-seats-among-districts-as-well","dir":"Articles","previous_headings":"4) Biproportional method","what":"4.2) Distribute seats among districts as well","title":"Apportionment scenarios","text":"Normally number seats per district defined election, based census data. However, also assign number seats per district, based actual votes cast every district. way, districts seat share proportional vote share. , use total number seats district_seats parameter. can see, number party seats change. However, districts people voted get higher share seats. 2 districts gain seats, 4 districts lose seat.","code":"full_biproportional = biproporz(votes_matrix,                                  district_seats = sum(district_seats),                                 use_list_votes = FALSE)  # party seat distribution has not changed rowSums(full_biproportional) - rowSums(seats_biproportional) #>   Asyl   E117   E118   E154   E168   E169   E185   E191   E192   E287   E491  #>      0      0      0      0      0      0      0      0      0      0      0  #>   E492   E493    EOP     FP     IP     KD   KESK    KOK     KP    KTP   LIBE  #>      0      0      0      0      0      0      0      0      0      0      0  #>    LII   LIIK     LN   LNLY    LNY   LNYL    Nyt    NYT    PEL    PIR     PS  #>      0      0      0      0      0      0      0      0      0      0      0  #>    REF Reform    RKP    RLI    SDP    SIN    SKE    SKP    STL    VAS   VIHR  #>      0      0      0      0      0      0      0      0      0      0      0  # district seat distribution is different colSums(full_biproportional) - colSums(seats_biproportional) #> HÄM HEL KAA KES LAP OUL PIR SAT SKA UUS VAA VAR  #>  -1   3  -1   0   0  -1   0   0  -1   0   0   1"},{"path":"https://polettif.github.io/proporz/articles/apportionment_scenarios.html","id":"effect-of-a-system-change-on-seat-distribution","dir":"Articles","previous_headings":"","what":"5) Effect of a system change on seat distribution","title":"Apportionment scenarios","text":"last example, ’ll look changes seat distribution biproportional apportionment 2020 parliament election Swiss canton Uri. Uri, 2020 first year cantonal parliament elected biproportional apportionment municipalities. Previously, four municipalities used Hagenbach-Bischoff method. ’ll ignore municipalities use majoritarian electoral system. Compared previous election system change one seat (37).","code":"seats_old_system = apply_proporz(uri2020$votes_matrix, uri2020$seats_vector, \"hagenbach-bischoff\")  seats_new_system = biproporz(uri2020$votes_matrix, uri2020$seats_vector)  seats_new_system-seats_old_system #>      Altdorf Bürglen Erstfeld Schattdorf #> CVP        1       0        0          0 #> SPGB      -1       0        0          0 #> FDP        0       0        0          0 #> SVP        0       0        0          0"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Modifying biproporz()","text":"vignette demonstrates modify extend default implementation biproportional apportionment biproporz(). cover following modifications: Applying quorum filter seat-eligible parties Using alternative predefined apportionment methods Implementing custom rounding function lower apportionment Altering Winner-Take-One (WTO) method bypass upper apportionment constraints ’ll begin creating custom dataset: matrix containing vote counts vector representing number seats per district.","code":"library(proporz)  # Define a custom dataset for this vignette votes_matrix = matrix(     c( 800, 2802, 4095,  0, 150,       3900,  814, 3990, 20,  60,       1400, 1302, 4305, 10,  80,          0,    0,    0, 50,   0,        610,  500, 1001, 40, 120),     ncol = 5, byrow = TRUE,     dimnames = list(         party = c(\"A\", \"B\", \"C\", \"D\", \"E\"),         district = c(\"City 1\", \"City 2\", \"City 3\", \"Region 4\", \"Region 5\")     ))  district_seats = setNames(c(5, 5, 14, 1, 1), colnames(votes_matrix))"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"analyzing-the-votes-matrix","dir":"Articles","previous_headings":"Introduction","what":"Analyzing the Votes Matrix","title":"Modifying biproporz()","text":"example votes_matrix, voter casts many votes seats district. understand party strength across districts, calculate number voters per party district weighting votes matrix weight_list_votes(): step performed within biproporz() parameter use_list_votes = TRUE. result matrix fractional voter counts, votes can split multiple parties.","code":"votes_matrix #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A    800   2802   4095        0      150 #>     B   3900    814   3990       20       60 #>     C   1400   1302   4305       10       80 #>     D      0      0      0       50        0 #>     E    610    500   1001       40      120  (voters = weight_list_votes(votes_matrix, district_seats)) #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A    160  560.4  292.5        0      150 #>     B    780  162.8  285.0       20       60 #>     C    280  260.4  307.5       10       80 #>     D      0    0.0    0.0       50        0 #>     E    122  100.0   71.5       40      120"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"standard-biproportional-apportionment","dir":"Articles","previous_headings":"","what":"Standard Biproportional Apportionment","title":"Modifying biproporz()","text":"default biproporz() method allocates seats based votes matrix district seats using standard rounding upper lower apportionments. Key observations standard apportionment: Party D receive enough votes across districts win seat. City 3, Party B receives seats despite fewer total votes two parties. Party E’s strongest district City 1 (122 voters), win seat . biproporz() function returns seat allocation matrix divisors hidden attributes (see get_divisors()). can print marginal sums (total seats per party district) divisors summary().","code":"seats_biproporz_standard = biproporz(votes_matrix, district_seats)  # Number of seats per party rowSums(seats_biproporz_standard) #> A B C D E  #> 8 9 6 0 3 summary(seats_biproporz_standard) #>            City 1 City 2 City 3 Region 4 Region 5 (sum) (divisor) #>          A      1      2      4        0        1     8      0.91 #>          B      3      1      5        0        0     9       0.8 #>          C      1      1      4        0        0     6         1 #>          D      0      0      0        0        0     0         1 #>          E      0      1      1        1        0     3      0.76 #>      (sum)      5      5     14        1        1    26           #>  (divisor)   1703   1286   1008      101      324  # You can transpose the matrix # summary(t(seats_biproporz_standard))"},{"path":[]},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"applying-a-quorum","dir":"Articles","previous_headings":"Modifying biproporz with Parameters","what":"Applying a Quorum","title":"Modifying biproporz()","text":"quorum can ensure parties minimum percentage number votes eligible seat allocation. example, impose 5% quorum total votes. actually change seat distribution compared standard method, Party D already “natural quorum” get enough votes seat.","code":"biproporz(votes_matrix, district_seats, quorum_any(total = 0.05)) #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A      1      2      4        0        1 #>     B      3      1      5        0        0 #>     C      1      1      4        0        0 #>     D      0      0      0        0        0 #>     E      0      1      1        1        0"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"alternative-apportionment-methods","dir":"Articles","previous_headings":"Modifying biproporz with Parameters","what":"Alternative Apportionment Methods","title":"Modifying biproporz()","text":"biproporz() allows specify different methods upper lower apportionment passing list method parameter. example, can use Adams method upper apportionment standard rounding lower apportionment.","code":"biproporz(votes_matrix, district_seats, method = list(\"adams\", \"round\")) #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A      1      2      5        0        0 #>     B      3      1      4        0        0 #>     C      1      1      4        0        0 #>     D      0      0      0        1        0 #>     E      0      1      1        0        1"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"custom-rounding-function","dir":"Articles","previous_headings":"Modifying biproporz with Parameters","what":"Custom Rounding Function","title":"Modifying biproporz()","text":"customize seat allocation, can define rounding function lower apportionment. ’s custom rounding function works follows: Values 0.7 rounded 0 Values equal greater 0.7 rounded 1 Standard rounding applies values greater 1 (.e. values .5 rounded ) Compared using standard rounding, parties E swap one seat cities 1 2.","code":"custom_rounding_func = function(x) {     stopifnot(all(x >= 0))     lt0.7 = x < 0.7     x[lt0.7] <- 0     x[!lt0.7] <- ceil_at(x[!lt0.7], 0.5)     x }  # The function must work with a matrix custom_rounding_func(matrix(c(0.5, 0.6, 1.5, 2.5), 2)) #>      [,1] [,2] #> [1,]    0    2 #> [2,]    0    3  # Apply custom rounding function in lower apportionment biproporz(votes_matrix, district_seats,            method = list(\"adams\", custom_rounding_func)) #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A      0      3      5        0        0 #>     B      3      1      4        0        0 #>     C      1      1      4        0        0 #>     D      0      0      0        1        0 #>     E      1      0      1        0        1"},{"path":[]},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"winner-take-one-wto","dir":"Articles","previous_headings":"District Winner Methods","what":"Winner-Take-One (WTO)","title":"Modifying biproporz()","text":"WTO method guarantees party votes district receive least one seat, given party eligible seat upper apportionment. two constraints may lead conflicts error, seen . Party D votes Region 4 get seat ’s party seat allocate. prevent case, quorum usually applied ensure large enough parties eligible seats.","code":"try(biproporz(votes_matrix, district_seats, method = \"wto\")) #> Error : Not enough upper apportionment seats to give district winner seats to party: 'D' biproporz(votes_matrix, district_seats, method = \"wto\",           quorum = quorum_any(total = 0.01)) #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A      1      2      4        0        1 #>     B      3      1      5        0        0 #>     C      1      1      4        0        0 #>     D      0      0      0        0        0 #>     E      0      1      1        1        0"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"wto-with-an-alternative-upper-apportionment-method","dir":"Articles","previous_headings":"District Winner Methods","what":"WTO with an Alternative Upper Apportionment Method","title":"Modifying biproporz()","text":"switching Adams method upper apportionment, Party D gets one seat (’ve already seen). resolves conflict, allowing WTO work lower apportionment.","code":"biproporz(votes_matrix, district_seats, method = list(\"adams\", \"wto\")) #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A      0      2      5        0        1 #>     B      3      1      4        0        0 #>     C      1      1      4        0        0 #>     D      0      0      0        1        0 #>     E      1      1      1        0        0"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"wto-with-ties","dir":"Articles","previous_headings":"District Winner Methods","what":"WTO with Ties","title":"Modifying biproporz()","text":"two parties number votes district (’s enought seats ), clear district winner WTO condition applied district. biproporz issues warning case, seen example: WTO suspended district 2, tied party Y gets seat district 1 distribution better satisfies constraints given upper apportionment. explicitly break tie (might necessary depending actual specifications) need modify votes matrix adding small vote amount district winner. workflow break ties randomly: can see, party Y now seat district 2 won tiebreaker. means turn party X must get seats district 1.","code":"(tied_votes = matrix(     c(1000, 500, 150, 150), 2,      dimnames = list(party = c(\"X\", \"Y\"), district = 1:2))) #>      district #> party    1   2 #>     X 1000 150 #>     Y  500 150 tied_votes_seats = setNames(c(2,1), colnames(tied_votes))  try(biproporz(tied_votes, tied_votes_seats, method = \"wto\")) #> Warning: Not enough seats for tied parties with the most votes in: '2' #> Winner take one condition is not applied in this district. #>      district #> party 1 2 #>     X 1 1 #>     Y 1 0 tied_districts = district_winner_matrix(tied_votes, tied_votes_seats) set.seed(4) for(d in seq_len(ncol(tied_votes))) {     if(anyNA(tied_districts[,d])) {         tied_parties = which(is.na(tied_districts[,d]))                  # break tie randomly         tiebreak_winner = sample(tied_parties, 1)         cat(\"party\", names(tiebreak_winner), \"wins district\", d)                  # assuming the impact of a small vote difference on          # the overall result is negligible         tied_votes[tiebreak_winner,d] <- tied_votes[tiebreak_winner,d]+1e-9     } } #> party Y wins district 2  biproporz(tied_votes, tied_votes_seats, method = \"wto\") #>      district #> party 1 2 #>     X 2 0 #>     Y 0 1"},{"path":"https://polettif.github.io/proporz/articles/modifying_biproporz.html","id":"guaranteeing-district-winners-a-seat","dir":"Articles","previous_headings":"District Winner Methods","what":"Guaranteeing District Winners a Seat","title":"Modifying biproporz()","text":"can modify WTO method ensure district winners always get seat, even don’t meet upper apportionment criteria. custom function implements approach. non-standard approach function adapted needed. Let’s compare standard biproportional apportionment modified method, guarantees district winners seat. example, Party D gains seat Party B. satisfy new constraints, changes district seat distributions Party Party E. Note method resolves possible conflicts district winners without upper apportionment seats, conflicts might arise. example, many district winners missing upper apportionment seats, constraints allocating remaining seats may become overly restrictive.","code":"biproporz_absolute_wto = function(votes_matrix, district_seats,                                   quorum = NULL, use_list_votes = TRUE) {     # 1) Identify unambiguous district winners     # Note: This step could also happen after the quorum has been applied     # (depending on the desired method implementation)     district_winners = district_winner_matrix(votes_matrix, district_seats)     district_winners[is.na(district_winners)] <- FALSE # Ignore ties      # 2) Apply quorum if specified     if(!is.null(quorum)) {         votes_matrix <- apply_quorum(votes_matrix, quorum)     }          # 3) Assign party seats in upper apportionment     ua = upper_apportionment(votes_matrix, district_seats,                               use_list_votes, method = \"round\")      # 4.1) Assign seats to district winners without      # enough upper apportionment seats     seats_without_ua = district_winners * 1     seats_without_ua[rowSums(district_winners) <= ua$party, ] <- 0          # 4.2) Biproportional apportionment for remaining seats     # Build votes matrix, set votes for district winners      # without enough upper apportionment seats to zero     biprop_votes_matrix = votes_matrix     biprop_votes_matrix[seats_without_ua > 0] <- 0          # Reduce the number of seats for districts that      # already had a \"insufficient district winner\" seat assigned     non_biprop_distr = colSums(seats_without_ua) > 0     biprop_district_seats = district_seats     biprop_district_seats[non_biprop_distr] <-          biprop_district_seats[non_biprop_distr] - 1          # Run biproporz     seats_biproporz = biproporz(biprop_votes_matrix, biprop_district_seats,                                  method = \"wto\")          # Remove divisor attributes, as they're no longer      # meaningful for the combined distribution     seats_biproporz <- as.matrix(seats_biproporz)          # 5) Return final seat distribution,     #    combining the two apportionments      return(seats_biproporz + seats_without_ua) } seats_biproporz_absolute_wto = biproporz_absolute_wto(votes_matrix, district_seats)  # Show the difference to the standard apportionment seats_biproporz_absolute_wto - seats_biproporz_standard #>      district #> party City 1 City 2 City 3 Region 4 Region 5 #>     A     -1      0      1        0        0 #>     B      0      0     -1        0        0 #>     C      0      0      0        0        0 #>     D      0      0      0        1        0 #>     E      1      0      0       -1        0"},{"path":"https://polettif.github.io/proporz/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Flavio Poletti. Author, maintainer, copyright holder.","code":""},{"path":"https://polettif.github.io/proporz/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Poletti F (2025). proporz: Proportional Apportionment. R package version 1.5.1, https://github.com/polettif/proporz, https://polettif.github.io/proporz/.","code":"@Manual{,   title = {proporz: Proportional Apportionment},   author = {Flavio Poletti},   year = {2025},   note = {R package version 1.5.1, https://github.com/polettif/proporz},   url = {https://polettif.github.io/proporz/}, }"},{"path":"https://polettif.github.io/proporz/index.html","id":"proporz-","dir":"","previous_headings":"","what":"Proportional Apportionment","title":"Proportional Apportionment","text":"Calculate seat apportionment legislative bodies various methods. methods include divisor methods (e.g. D’Hondt, Webster Adams), largest remainder methods biproportional apportionment. Mit diesem R-Package können mittels verschiedener Sitzzuteilungsverfahren Wählerstimmen Abgeordnetensitze umgerechnet werden. Das Package beinhaltet Quoten-, Divisor- und biproportionale Verfahren (Doppelproporz oder “Doppelter Pukelsheim”).","code":""},{"path":"https://polettif.github.io/proporz/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Proportional Apportionment","text":"Install package CRAN: Alternatively, install development version Github:","code":"install.packages(\"proporz\") # install.packages(\"remotes\") remotes::install_github(\"polettif/proporz\")"},{"path":[]},{"path":"https://polettif.github.io/proporz/index.html","id":"proportional-apportionment","dir":"","previous_headings":"Apportionment methods overview","what":"Proportional Apportionment","title":"Proportional Apportionment","text":"proporz() distributes seats proportionally vector votes according following methods: D’Hondt, Jefferson, Hagenbach-Bischoff Sainte-Laguë, Webster Adams Dean Huntington-Hill Hare-Niemeyer, Hamilton, Vinton","code":"library(proporz) votes = c(\"Party A\" = 651, \"Party B\" = 349, \"Party C\" = 50)  proporz(votes, n_seats = 10, method = \"sainte-lague\") #> Party A Party B Party C  #>       7       3       0  proporz(votes, 10, \"huntington-hill\", quorum = 0.05) #> Party A Party B Party C  #>       6       4       0"},{"path":"https://polettif.github.io/proporz/index.html","id":"biproportional-apportionment","dir":"","previous_headings":"Apportionment methods overview","what":"Biproportional Apportionment","title":"Proportional Apportionment","text":"Biproportional apportionment (Wikipedia) method proportionally allocate seats among parties districts. can use provided uri2020 data set illustrate biproportional apportionment biproporz(). need ‘votes matrix’ input shows number votes party (rows) district (columns). also need define number seats per district. can use pukelsheim() dataframes long format input data. wrapper biproporz(). zug2018 shows actual election result Canton Zug dataframe. use data set create input data pukelsheim(). parameters set reflect actual election system. Apportionment scenarios vignette contains examples. adapt biproporz special use cases demonstrated Modifying biproporz() vignette.","code":"(votes_matrix <- uri2020$votes_matrix) #>      Altdorf Bürglen Erstfeld Schattdorf #> CVP    11471    2822     2309       4794 #> SPGB   11908    1606     1705       2600 #> FDP     9213    1567      946       2961 #> SVP     7756    2945     1573       3498  (district_seats <- uri2020$seats_vector) #>    Altdorf    Bürglen   Erstfeld Schattdorf  #>         15          7          6          9  biproporz(votes_matrix, district_seats) #>      Altdorf Bürglen Erstfeld Schattdorf #> CVP        5       2        2          3 #> SPGB       4       1        2          2 #> FDP        3       1        1          2 #> SVP        3       3        1          2 # In this data set, parties are called 'lists' and districts 'entities'. votes_df = unique(zug2018[c(\"list_id\", \"entity_id\", \"list_votes\")]) district_seats_df = unique(zug2018[c(\"entity_id\", \"election_mandates\")])  seats_df = pukelsheim(votes_df,                       district_seats_df,                       quorum = quorum_any(any_district = 0.05, total = 0.03),                       winner_take_one = TRUE)  head(seats_df) #>   list_id entity_id list_votes seats #> 1       2      1701       8108     2 #> 2       1      1701       2993     0 #> 3       3      1701      19389     3 #> 4       4      1701      14814     2 #> 5       5      1701       4486     1 #> 6       6      1701      15695     3"},{"path":"https://polettif.github.io/proporz/index.html","id":"shiny-app","dir":"","previous_headings":"","what":"Shiny app","title":"Proportional Apportionment","text":"package provides basic Shiny app can calculate biproportional apportionment interactive dashboard. need packages shiny shinyMatrix installed. Try shinyapps.io","code":"# install.packages(\"shiny\") # install.packages(\"shinyMatrix\") proporz::run_app()"},{"path":"https://polettif.github.io/proporz/index.html","id":"function-details","dir":"","previous_headings":"","what":"Function details","title":"Proportional Apportionment","text":"Full function reference","code":""},{"path":"https://polettif.github.io/proporz/index.html","id":"divisor-methods","dir":"","previous_headings":"Function details","what":"Divisor methods","title":"Proportional Apportionment","text":"can use divisor methods directly:","code":"votes = c(\"Party A\" = 690, \"Party B\" = 370, \"Party C\" = 210, \"Party D\" = 10)  # D'Hondt, Jefferson or Hagenbach-Bischoff method divisor_floor(votes, 10) #> Party A Party B Party C Party D  #>       6       3       1       0  # Sainte-Laguë or Webster method divisor_round(votes, 10) #> Party A Party B Party C Party D  #>       5       3       2       0  # Adams method divisor_ceiling(votes, 10) #> Party A Party B Party C Party D  #>       4       3       2       1  # Dean method divisor_harmonic(votes, 10) #> Party A Party B Party C Party D  #>       5       2       2       1  # Huntington-Hill method divisor_geometric(votes, 10) #> Party A Party B Party C Party D  #>       5       3       1       1"},{"path":"https://polettif.github.io/proporz/index.html","id":"largest-remainder-method","dir":"","previous_headings":"Function details","what":"Largest remainder method","title":"Proportional Apportionment","text":"largest remainder method also accessible directly:","code":"votes = c(\"I\" = 16200, \"II\" = 47000, \"III\" = 12700)  # Hamilton, Hare-Niemeyer or Vinton method largest_remainder_method(votes, 20) #>   I  II III  #>   4  13   3"},{"path":"https://polettif.github.io/proporz/index.html","id":"see-also","dir":"","previous_headings":"","what":"See also","title":"Proportional Apportionment","text":"R packages available provide apportionment functions, focus analysis. However, biproportional apportionment missing pure R packages RBazi needs rJava accompanying jar. RBazi: Package using rJava access functions BAZI. seatdist: Package seat apportionment disproportionality measurement. disprr: Simulate election results examine disproportionality apportionment methods. apportR: Package containing various apportionment methods, particular relevance problem apportioning seats House Representatives. apportion: Convert populations integer number seats legislative bodies, focusing United States.","code":""},{"path":"https://polettif.github.io/proporz/index.html","id":"contributing","dir":"","previous_headings":"See also","what":"Contributing","title":"Proportional Apportionment","text":"Please feel free issue pull request open issue.","code":""},{"path":"https://polettif.github.io/proporz/reference/apply_quorum.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply quorum to votes vector or matrix — apply_quorum","title":"Apply quorum to votes vector or matrix — apply_quorum","text":"quorum calculation implementation called within proporz(), biproporz() related functions. Generally, need call apply_quorum directly.","code":""},{"path":"https://polettif.github.io/proporz/reference/apply_quorum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply quorum to votes vector or matrix — apply_quorum","text":"","code":"apply_quorum(votes, quorum)"},{"path":"https://polettif.github.io/proporz/reference/apply_quorum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply quorum to votes vector or matrix — apply_quorum","text":"votes votes vector votes matrix quorum Depending votes: vector: Vote threshold party must reach. Used fraction total votes less 1 otherwise number votes. matrix: List quorum functions (created quorum_functions) logical vector length number votes rows.","code":""},{"path":"https://polettif.github.io/proporz/reference/apply_quorum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply quorum to votes vector or matrix — apply_quorum","text":"Vector matrix dimension votes. Parties failed reach specified quorum votes set zero.","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/apply_quorum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply quorum to votes vector or matrix — apply_quorum","text":"","code":"# vector (votes = c(81, 9, 10)) #> [1] 81  9 10  apply_quorum(votes, 10) #> [1] 81  0 10  apply_quorum(votes, .11) #> [1] 81  0  0  # matrix (votes_matrix = matrix(c(91, 9, 199, 1), nrow = 2)) #>      [,1] [,2] #> [1,]   91  199 #> [2,]    9    1  apply_quorum(votes_matrix, quorum_all(total = 0.1)) #>      [,1] [,2] #> [1,]   91  199 #> [2,]    0    0  apply_quorum(votes_matrix, c(FALSE, TRUE)) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    9    1"},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":null,"dir":"Reference","previous_headings":"","what":"Biproportional apportionment — biproporz","title":"Biproportional apportionment — biproporz","text":"Method proportionally allocate seats among parties (lists) districts (entities, regions), thus bi-proportional.","code":""},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Biproportional apportionment — biproporz","text":"","code":"biproporz(   votes_matrix,   district_seats,   quorum,   use_list_votes = TRUE,   method = \"round\" )"},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Biproportional apportionment — biproporz","text":"votes_matrix Vote count matrix votes party rows votes district columns. district_seats Vector defining number seats per district. Must length ncol(votes_matrix). Values name-matched votes_matrix columns named. number seats per district calculated according number votes (general use case), single number total number seats can used. quorum Optional list functions take votes_matrix return logical vector denotes party/row whether reached quorum (.e. eligible seats). easiest way via quorum_any() quorum_all(), see examples. Alternatively can pass precalculated logical vector. quorum applied parameter missing NULL. use_list_votes default (TRUE) assumed voter district many votes seats district. Thus, votes weighted according number available district seats weight_list_votes(). Set FALSE votes_matrix shows number voters (.e. can cast one vote one party). method Defines method used assign seats. following methods recommended: round: Uses Sainte-Laguë/Webster method (rounding half ) upper lower apportionment standard biproportional apportionment method guaranteed terminate. wto: \"winner take one\" works like \"round\" condition party got votes district must get least one seat ('Majorzbedingung') said district. applies got enough seats upper apportionment (uses Sainte-Laguë/Webster method). See lower_apportionment() details. also possible use divisor method name listed proporz(). want use different method upper lower apportionment, provide list two entries.","code":""},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Biproportional apportionment — biproporz","text":"Matrix dimension votes_matrix containing number seats row column divisors stored attributes (hidden print, see get_divisors()).","code":""},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Biproportional apportionment — biproporz","text":"party nominates candidate list every district. voters vote parties district. seat allocation calculated two steps: called upper apportionment number seats party (districts) determined. Normally, number seats region defined election independent vote counts. called lower apportionment seats distributed regional party list respecting results upper apportionment. Parties failing reach quorums get seats. function handle seat assignment candidates.","code":""},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Biproportional apportionment — biproporz","text":"iterative process lower apportionment guaranteed terminate default Sainte-Laguë/Webster method.","code":""},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Biproportional apportionment — biproporz","text":"Gaffke, Norbert; Pukelsheim, Friedrich (2008): Divisor methods proportional representation systems: optimization approach vector matrix apportionment problems. Mathematical Social Sciences, 56 (2), 166-184.","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/biproporz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Biproportional apportionment — biproporz","text":"","code":"votes_matrix = uri2020$votes_matrix district_seats = uri2020$seats_vector  biproporz(votes_matrix, district_seats) #>      Altdorf Bürglen Erstfeld Schattdorf #> CVP        5       2        2          3 #> SPGB       4       1        2          2 #> FDP        3       1        1          2 #> SVP        3       3        1          2  # apply quorum (high values for illustrative purposes) biproporz(votes_matrix, district_seats,           quorum_all(any_district = 0.1, total = 0.25)) #>      Altdorf Bürglen Erstfeld Schattdorf #> CVP        7       5        3          6 #> SPGB       8       2        3          3 #> FDP        0       0        0          0 #> SVP        0       0        0          0"},{"path":"https://polettif.github.io/proporz/reference/ceil_at.html","id":null,"dir":"Reference","previous_headings":"","what":"Rounding with predefined thresholds — ceil_at","title":"Rounding with predefined thresholds — ceil_at","text":"Round x ceiling(x) x-floor(x) >= threshold, otherwise round floor(x).","code":""},{"path":"https://polettif.github.io/proporz/reference/ceil_at.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rounding with predefined thresholds — ceil_at","text":"","code":"ceil_at(x, threshold)"},{"path":"https://polettif.github.io/proporz/reference/ceil_at.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rounding with predefined thresholds — ceil_at","text":"x numeric vector matrix >= 0 (NaN supported) threshold threshold [0,1] \"harmonic\"/\"geometric\" use harmonic geometric mean thresholds","code":""},{"path":"https://polettif.github.io/proporz/reference/ceil_at.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rounding with predefined thresholds — ceil_at","text":"rounded vector matrix","code":""},{"path":"https://polettif.github.io/proporz/reference/ceil_at.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rounding with predefined thresholds — ceil_at","text":"","code":"ceil_at(c(0.5, 1.5, 2.49, 2.5, 2.51), 0.5) #> [1] 1 2 2 3 3 # compare to round(c(0.5, 1.5, 2.49, 2.5, 2.51)) #> [1] 0 2 2 2 3  ceil_at(c(1.45, 2.45, 3.45), 0) # like floor() #> [1] 2 3 4 ceil_at(c(1.45, 2.45, 3.45, 0.2), \"geometric\") #> [1] 2 3 3 1"},{"path":"https://polettif.github.io/proporz/reference/district_winner_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Find which party has the most votes in a district — district_winner_matrix","title":"Find which party has the most votes in a district — district_winner_matrix","text":"Create logical matrix shows whether party got votes district .","code":""},{"path":"https://polettif.github.io/proporz/reference/district_winner_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find which party has the most votes in a district — district_winner_matrix","text":"","code":"district_winner_matrix(votes_matrix, district_seats = 1L)"},{"path":"https://polettif.github.io/proporz/reference/district_winner_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find which party has the most votes in a district — district_winner_matrix","text":"votes_matrix Vote count matrix votes party rows votes district columns. district_seats Vector defining number seats per district. Must length ncol(votes_matrix). Values name-matched votes_matrix columns named. single value supplied (like 1 default), used number seats every district.","code":""},{"path":"https://polettif.github.io/proporz/reference/district_winner_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find which party has the most votes in a district — district_winner_matrix","text":"logical matrix dimensions names votes_matrix","code":""},{"path":"https://polettif.github.io/proporz/reference/district_winner_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find which party has the most votes in a district — district_winner_matrix","text":"two parties tied enough seats tied party, matrix value NA.","code":""},{"path":"https://polettif.github.io/proporz/reference/district_winner_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find which party has the most votes in a district — district_winner_matrix","text":"","code":"(vm = matrix(c(60,30,0,20,10,30), nrow = 3, dimnames = list(1:3, c(\"A\", \"B\")))) #>    A  B #> 1 60 20 #> 2 30 10 #> 3  0 30  district_winner_matrix(vm) #>       A     B #> 1  TRUE FALSE #> 2 FALSE FALSE #> 3 FALSE  TRUE  # NA values if parties are tied (here in district B) vm[1,2] <- 30 district_winner_matrix(vm) #>       A     B #> 1  TRUE    NA #> 2 FALSE FALSE #> 3 FALSE    NA  # No NA values for tied parties if enough seats are available district_winner_matrix(vm, c(1, 2)) #>       A     B #> 1  TRUE  TRUE #> 2 FALSE FALSE #> 3 FALSE  TRUE"},{"path":"https://polettif.github.io/proporz/reference/divide_votes_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate raw seat matrix — divide_votes_matrix","title":"Calculate raw seat matrix — divide_votes_matrix","text":"Apply row column divisors matrix get non-rounded seat values.","code":""},{"path":"https://polettif.github.io/proporz/reference/divide_votes_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate raw seat matrix — divide_votes_matrix","text":"","code":"divide_votes_matrix(M, col_divisors, row_divisors)"},{"path":"https://polettif.github.io/proporz/reference/divide_votes_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate raw seat matrix — divide_votes_matrix","text":"M matrix col_divisors divisors apply columns row_divisors divisors apply rows","code":""},{"path":"https://polettif.github.io/proporz/reference/divide_votes_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate raw seat matrix — divide_votes_matrix","text":"matrix dimension M containing non-rounded seat values","code":""},{"path":"https://polettif.github.io/proporz/reference/divisor_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Divisor methods — divisor_methods","title":"Divisor methods — divisor_methods","text":"Functions directly apply divisor apportionment methods instead calling proporz() method parameter. divisor functions call highest_averages_method() different sequence divisors.","code":""},{"path":"https://polettif.github.io/proporz/reference/divisor_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divisor methods — divisor_methods","text":"","code":"divisor_round(votes, n_seats, quorum = 0)  divisor_floor(votes, n_seats, quorum = 0)  divisor_harmonic(votes, n_seats, quorum = 0)  divisor_geometric(votes, n_seats, quorum = 0)  divisor_ceiling(votes, n_seats, quorum = 0)"},{"path":"https://polettif.github.io/proporz/reference/divisor_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divisor methods — divisor_methods","text":"votes numeric vector number votes party n_seats total number seats quorum Vote threshold party must reach. Used fraction total votes within less 1 otherwise number votes.","code":""},{"path":"https://polettif.github.io/proporz/reference/divisor_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divisor methods — divisor_methods","text":"number seats per party vector","code":""},{"path":"https://polettif.github.io/proporz/reference/divisor_methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divisor methods — divisor_methods","text":"Divisor methods known different names: d'hondt, jefferson, hagenbach-bischoff: divisor_floor() sainte-lague, webster: divisor_round() adams: divisor_ceiling() dean: divisor_harmonic() huntington-hill, hill-huntington: divisor_geometric()","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/divisor_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divisor methods — divisor_methods","text":"","code":"votes = c(\"Party A\" = 690, \"Party B\" = 400,           \"Party C\" = 250, \"Party D\" = 120)  divisor_round(votes, 10) #> Party A Party B Party C Party D  #>       4       3       2       1   divisor_floor(votes, 10) #> Party A Party B Party C Party D  #>       5       3       2       0   divisor_ceiling(votes, 10) #> Party A Party B Party C Party D  #>       4       3       2       1   divisor_ceiling(votes, 5) #> Party A Party B Party C Party D  #>       2       1       1       1   divisor_geometric(votes, 10, quorum = 0.05) #> Party A Party B Party C Party D  #>       4       3       2       1   divisor_harmonic(votes, 10) #> Party A Party B Party C Party D  #>       4       3       2       1"},{"path":"https://polettif.github.io/proporz/reference/find_divisor.html","id":null,"dir":"Reference","previous_headings":"","what":"Find divisor to assign seats — find_divisor","title":"Find divisor to assign seats — find_divisor","text":"Find divisor divisor_from divisor_to sum(round_func(votes/divisor)) equals target_seats","code":""},{"path":"https://polettif.github.io/proporz/reference/find_divisor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find divisor to assign seats — find_divisor","text":"","code":"find_divisor(votes, divisor_from, divisor_to, target_seats, round_func)"},{"path":"https://polettif.github.io/proporz/reference/find_divisor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find divisor to assign seats — find_divisor","text":"votes votes (matrix one column vector, allows use row/colnames within round_func) divisor_from lower bound divisor search range (decreased necessary) divisor_to upper bound divisor search range (increased necessary) target_seats number seats distribute (single number) round_func rounding function","code":""},{"path":"https://polettif.github.io/proporz/reference/find_divisor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find divisor to assign seats — find_divisor","text":"divisor","code":""},{"path":"https://polettif.github.io/proporz/reference/find_matrix_divisors.html","id":null,"dir":"Reference","previous_headings":"","what":"Find divisors for a matrix with alternate scaling — find_matrix_divisors","title":"Find divisors for a matrix with alternate scaling — find_matrix_divisors","text":"Find divisors matrix alternate scaling","code":""},{"path":"https://polettif.github.io/proporz/reference/find_matrix_divisors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find divisors for a matrix with alternate scaling — find_matrix_divisors","text":"","code":"find_matrix_divisors(M, seats_cols, seats_rows, round_func)"},{"path":"https://polettif.github.io/proporz/reference/find_matrix_divisors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find divisors for a matrix with alternate scaling — find_matrix_divisors","text":"M votes_matrix seats_cols target seats column seats_rows target seats row round_func rounding function. Called like round_func(M/row_divisors/col_divisors), divisors applied row/col-wise divide_votes_matrix().","code":""},{"path":"https://polettif.github.io/proporz/reference/find_matrix_divisors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find divisors for a matrix with alternate scaling — find_matrix_divisors","text":"list divisors (column row)","code":""},{"path":"https://polettif.github.io/proporz/reference/finland2019.html","id":null,"dir":"Reference","previous_headings":"","what":"Finnish Parliamentary Elections Data (2019) — finland2019","title":"Finnish Parliamentary Elections Data (2019) — finland2019","text":"Example data 2019 Finnish parliamentary elections. data cleaned contains information relevant package.","code":""},{"path":"https://polettif.github.io/proporz/reference/finland2019.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finnish Parliamentary Elections Data (2019) — finland2019","text":"","code":"finland2019"},{"path":"https://polettif.github.io/proporz/reference/finland2019.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Finnish Parliamentary Elections Data (2019) — finland2019","text":"List containing two data.frames: votes_df containing number votes party district. 229 rows, 3 columns (party_name, district_name, votes) district_seats_df number seats per district. 12 rows, 2 columns (district_name, seats)","code":""},{"path":"https://polettif.github.io/proporz/reference/finland2019.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Finnish Parliamentary Elections Data (2019) — finland2019","text":"https://tulospalvelu.vaalit.fi/EKV-2019/en/ladattavat_tiedostot.html","code":""},{"path":"https://polettif.github.io/proporz/reference/finland2019.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finnish Parliamentary Elections Data (2019) — finland2019","text":"","code":"finland2019$district_seats_df #>    district_name seats #> 1            HEL    22 #> 2            HÄM    14 #> 3            KAA    17 #> 4            KES    10 #> 5            LAP     7 #> 6            OUL    18 #> 7            PIR    19 #> 8            SAT     8 #> 9            SKA    15 #> 10           UUS    36 #> 11           VAA    16 #> 12           VAR    17  head(finland2019$votes_df) #>   party_name district_name  votes #> 1        KOK           UUS 114243 #> 2        SDP           UUS  97107 #> 3       VIHR           HEL  90662 #> 4         PS           UUS  86691 #> 5        KOK           HEL  84141 #> 6       KESK           OUL  78486"},{"path":"https://polettif.github.io/proporz/reference/get_divisors.html","id":null,"dir":"Reference","previous_headings":"","what":"Get district and party divisors from biproporz result — get_divisors","title":"Get district and party divisors from biproporz result — get_divisors","text":"Show district party divisors used assign seats. method provides easier access divisors stored attributes(...)$divisors.","code":""},{"path":"https://polettif.github.io/proporz/reference/get_divisors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get district and party divisors from biproporz result — get_divisors","text":"","code":"get_divisors(biproporz_result)"},{"path":"https://polettif.github.io/proporz/reference/get_divisors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get district and party divisors from biproporz result — get_divisors","text":"biproporz_result matrix created biproporz() data.frame created pukelsheim()","code":""},{"path":"https://polettif.github.io/proporz/reference/get_divisors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get district and party divisors from biproporz result — get_divisors","text":"district party divisors (named \"districts\" \"parties\") list, vector","code":""},{"path":"https://polettif.github.io/proporz/reference/get_divisors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get district and party divisors from biproporz result — get_divisors","text":"","code":"seats_matrix = biproporz(uri2020$votes_matrix, uri2020$seats_vector) get_divisors(seats_matrix) #> $districts #>    Altdorf    Bürglen   Erstfeld Schattdorf  #>       2689       1194       1088       1539  #>  #> $parties #>   CVP  SPGB   FDP   SVP  #> 0.946 1.000 1.000 0.970  #>   seats_df = pukelsheim(pivot_to_df(uri2020$votes_matrix),                       data.frame(names(uri2020$seats_vector), uri2020$seats_vector)) get_divisors(seats_df) #> $districts #>    Altdorf    Bürglen   Erstfeld Schattdorf  #>       2689       1194       1088       1539  #>  #> $parties #>   CVP   FDP  SPGB   SVP  #> 0.946 1.000 1.000 0.970  #>   # summary() also prints the divisors for a biproporz matrix summary(seats_matrix) #>            Altdorf Bürglen Erstfeld Schattdorf (sum) (divisor) #>        CVP       5       2        2          3    12     0.946 #>       SPGB       4       1        2          2     9         1 #>        FDP       3       1        1          2     7         1 #>        SVP       3       3        1          2     9      0.97 #>      (sum)      15       7        6          9    37           #>  (divisor)    2689    1194     1088       1539"},{"path":"https://polettif.github.io/proporz/reference/highest_averages_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Highest averages method — highest_averages_method","title":"Highest averages method — highest_averages_method","text":"Allocate seats proportionally divisor methods.","code":""},{"path":"https://polettif.github.io/proporz/reference/highest_averages_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Highest averages method — highest_averages_method","text":"","code":"highest_averages_method(votes, n_seats, divisors)"},{"path":"https://polettif.github.io/proporz/reference/highest_averages_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Highest averages method — highest_averages_method","text":"votes numeric vector number votes party n_seats total number seats divisors sequence divisors (length equal number seats). single number (e.g. 0.5), sequence generated starting , increasing 1.","code":""},{"path":"https://polettif.github.io/proporz/reference/highest_averages_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Highest averages method — highest_averages_method","text":"number seats per party vector","code":""},{"path":"https://polettif.github.io/proporz/reference/highest_averages_method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Highest averages method — highest_averages_method","text":"highest averages method requires number votes party divided successively series divisors. produces table quotients, averages, row divisor column party. nth seat allocated party whose column contains nth largest entry table, total number seats available. (Wikipedia)","code":""},{"path":"https://polettif.github.io/proporz/reference/highest_averages_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Highest averages method — highest_averages_method","text":"","code":"highest_averages_method(c(5200, 1700, 3100), 15, 0.5) #> [1] 8 2 5  highest_averages_method(votes = c(50, 0, 30), n_seats = 3,                         divisors = c(0, 1.3333, 2.4)) #> [1] 2 0 1"},{"path":"https://polettif.github.io/proporz/reference/largest_remainder_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Largest remainder method — largest_remainder_method","title":"Largest remainder method — largest_remainder_method","text":"Allocate seats based largest fractional remainder. largest remainder method also known : Hamilton, Hare-Niemeyer Vinton method.","code":""},{"path":"https://polettif.github.io/proporz/reference/largest_remainder_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Largest remainder method — largest_remainder_method","text":"","code":"largest_remainder_method(votes, n_seats, quorum = 0)"},{"path":"https://polettif.github.io/proporz/reference/largest_remainder_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Largest remainder method — largest_remainder_method","text":"votes numeric vector number votes party n_seats total number seats quorum Vote threshold party must reach. Used fraction total votes within less 1 otherwise number votes.","code":""},{"path":"https://polettif.github.io/proporz/reference/largest_remainder_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Largest remainder method — largest_remainder_method","text":"number seats per party vector","code":""},{"path":"https://polettif.github.io/proporz/reference/largest_remainder_method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Largest remainder method — largest_remainder_method","text":"numbers votes party divided quota representing number votes required seat. , party receives rounded quota value seats. remaining seats given party largest remainder seats distributed.","code":""},{"path":"https://polettif.github.io/proporz/reference/largest_remainder_method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Largest remainder method — largest_remainder_method","text":"quota total votes / total seats (used aforementioned methods) implemented.","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/largest_remainder_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Largest remainder method — largest_remainder_method","text":"","code":"votes = c(47000, 16000, 15800, 12000, 6100, 3100) largest_remainder_method(votes, 10) #> [1] 5 2 1 1 1 0"},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower apportionment — lower_apportionment","title":"Lower apportionment — lower_apportionment","text":"second biproportional apportionment step, party district divisors calculated row column sums resulting seats matrix satisfy constraints given upper apportionment.","code":""},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower apportionment — lower_apportionment","text":"","code":"lower_apportionment(votes_matrix, seats_cols, seats_rows, method = \"round\")"},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lower apportionment — lower_apportionment","text":"votes_matrix matrix votes party rows votes district columns. seats_cols number seats per column (districts/regions), predetermined calculated upper_apportionment(). seats_rows number seats per row (parties/lists), calculated upper_apportionment(). method Apportion method defines seats assigned. following methods supported: round: default Sainte-Laguë/Webster method standard biproportional apportionment method guaranteed terminate. wto: \"winner take one\" works like round condition party got votes district must get least one seat ('Majorzbedingung', also called 'strongest party constrained' rule (SPC)). votes_matrix must row column names use method. district winner can get seat entitled one upper apportionment (seats_rows). condition apply district two parties number votes enough seats parties. warning issued case. Modify votes matrix explicitly break ties. can provide custom function rounds matrix (.e. votes_matrix divided party district divisors) without parameters. possible use divisor method name listed proporz().","code":""},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lower apportionment — lower_apportionment","text":"seat matrix district (columns) party (rows) divisors stored attributes.","code":""},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lower apportionment — lower_apportionment","text":"result obtained iterative process ('Alternate Scaling Algorithm', see Reference). Initially, district divisor chosen using highest averages method votes allocated regional party list region. party party divisor initialized 1. Effectively, objective iterative process modify regional divisors party divisors number seats regional party list equals number votes divided regional party divisors. following two correction steps executed objective satisfied: modify party divisors apportionment within party correct chosen rounding method, modify regional divisors apportionment within region correct chosen rounding method.","code":""},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Lower apportionment — lower_apportionment","text":"maximum number optimization iterations reached, error thrown since solution can found. can overwrite default (1000) options(proporz_max_iterations = ...) likely result undefined given structure input parameters.","code":""},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lower apportionment — lower_apportionment","text":"Oelbermann, K. F. (2016): Alternate scaling algorithm biproportional divisor methods. Mathematical Social Sciences, 80, 25-32.","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/lower_apportionment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lower apportionment — lower_apportionment","text":"","code":"votes_matrix = matrix(c(123,912,312,45,714,255,815,414,215), nrow = 3) district_seats = c(7,5,8) party_seats = c(5,11,4)  lower_apportionment(votes_matrix, district_seats, party_seats) #>      [,1] [,2] [,3] #> [1,]    1    0    4 #> [2,]    4    4    3 #> [3,]    2    1    1 #> attr(,\"divisors\") #> attr(,\"divisors\")$districts #> [1] 204 180 162 #>  #> attr(,\"divisors\")$parties #> [1] 1.2 1.0 1.0 #>    # using \"winner take one\" vm = matrix(c(200,100,10,11), 2,             dimnames = list(c(\"Party A\", \"Party B\"), c(\"I\", \"II\"))) district_seats = setNames(c(2,1), colnames(vm)) ua = upper_apportionment(vm, district_seats)  lower_apportionment(vm, ua$district, ua$party, method = \"wto\") #>         I II #> Party A 2  0 #> Party B 0  1 #> attr(,\"divisors\") #> attr(,\"divisors\")$districts #>   I  II  #> 144  31  #>  #> attr(,\"divisors\")$parties #> Party A Party B  #>     0.7     2.0  #>   # compare to standard method lower_apportionment(vm, ua$district, ua$party, method = \"round\") #>         I II #> Party A 1  1 #> Party B 1  0 #> attr(,\"divisors\") #> attr(,\"divisors\")$districts #>   I  II  #> 150  21  #>  #> attr(,\"divisors\")$parties #> Party A Party B  #>     0.9     1.2  #>"},{"path":"https://polettif.github.io/proporz/reference/pivot_to_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Pivot long data.frame to wide matrix and vice versa — pivot_to_matrix","title":"Pivot long data.frame to wide matrix and vice versa — pivot_to_matrix","text":"Create matrix 'wide' format data.frame 3 columns pivot_to_matrix create data.frame long format matrix pivot_to_df.","code":""},{"path":"https://polettif.github.io/proporz/reference/pivot_to_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pivot long data.frame to wide matrix and vice versa — pivot_to_matrix","text":"","code":"pivot_to_matrix(df_long)  pivot_to_df(matrix_wide, value_colname = \"values\")"},{"path":"https://polettif.github.io/proporz/reference/pivot_to_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pivot long data.frame to wide matrix and vice versa — pivot_to_matrix","text":"df_long data.frame long format exactly 3 columns matrix_wide matrix wide format value_colname name new value column resulting data.frame","code":""},{"path":"https://polettif.github.io/proporz/reference/pivot_to_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pivot long data.frame to wide matrix and vice versa — pivot_to_matrix","text":"data.frame 3 columns matrix. Note results sorted first second column (data.frame) row/column names (matrix).","code":""},{"path":"https://polettif.github.io/proporz/reference/pivot_to_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pivot long data.frame to wide matrix and vice versa — pivot_to_matrix","text":"pivot functions used prepare data biproporz() pukelsheim(). supposed cover general use cases provide customization. mainly exist reshape hard handle package dependencies.","code":""},{"path":"https://polettif.github.io/proporz/reference/pivot_to_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pivot long data.frame to wide matrix and vice versa — pivot_to_matrix","text":"","code":"# From data.frame to matrix df = data.frame(party = c(\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"),                 region = c(\"III\", \"II\", \"I\", \"I\", \"II\", \"III\"),                 seats = c(5L, 3L, 1L, 2L, 4L, 6L)) pivot_to_matrix(df) #>      region #> party I II III #>     A 1  3   5 #>     B 2  4   6  # from matrix to data.frame mtrx = matrix(1:6, nrow = 2) pivot_to_df(mtrx) #>   row col values #> 1   1   1      1 #> 2   1   2      3 #> 3   1   3      5 #> 4   2   1      2 #> 5   2   2      4 #> 6   2   3      6  # from matrix to data.frame using dimnames dimnames(mtrx) <- list(party = c(\"A\", \"B\"), region = c(\"I\", \"II\", \"III\")) pivot_to_df(mtrx, \"seats\") #>   party region seats #> 1     A      I     1 #> 2     A     II     3 #> 3     A    III     5 #> 4     B      I     2 #> 5     B     II     4 #> 6     B    III     6  # Note that pivot results are sorted pivot_to_df(pivot_to_matrix(df)) == df[order(df[[1]], df[[2]]),] #>      party region values #> [1,]  TRUE   TRUE   TRUE #> [2,]  TRUE   TRUE   TRUE #> [3,]  TRUE   TRUE   TRUE #> [4,]  TRUE   TRUE   TRUE #> [5,]  TRUE   TRUE   TRUE #> [6,]  TRUE   TRUE   TRUE"},{"path":"https://polettif.github.io/proporz/reference/proporz.html","id":null,"dir":"Reference","previous_headings":"","what":"Proportional apportionment — proporz","title":"Proportional apportionment — proporz","text":"Calculate seat apportionment legislative bodies.","code":""},{"path":"https://polettif.github.io/proporz/reference/proporz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proportional apportionment — proporz","text":"","code":"proporz(votes, n_seats, method, quorum = 0)"},{"path":"https://polettif.github.io/proporz/reference/proporz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proportional apportionment — proporz","text":"votes numeric vector number votes party n_seats total number seats method Apportionment method use, character. case sensitive. See details. quorum Vote threshold party must reach. Used fraction total votes within less 1 otherwise number votes.","code":""},{"path":"https://polettif.github.io/proporz/reference/proporz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proportional apportionment — proporz","text":"number seats per party vector","code":""},{"path":"https://polettif.github.io/proporz/reference/proporz.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Proportional apportionment — proporz","text":"following methods available: d'hondt, jefferson, hagenbach-bischoff, floor: divisor_floor() sainte-lague, webster, round: divisor_round() adams, ceiling: divisor_ceiling() dean, harmonic: divisor_harmonic() huntington-hill, hill-huntington, geometric: divisor_geometric() hare-niemeyer, hamilton, vinton, largest_remainder_method: largest_remainder_method()","code":""},{"path":"https://polettif.github.io/proporz/reference/proporz.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Proportional apportionment — proporz","text":"Seats can also apportioned among regions instead parties. parameter votes normally used census data (e.g. population counts).","code":""},{"path":"https://polettif.github.io/proporz/reference/proporz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Proportional apportionment — proporz","text":"","code":"votes = c(\"Party A\" = 651, \"Party B\" = 349, \"Party C\" = 50)  proporz(votes, 10, \"sainte-lague\") #> Party A Party B Party C  #>       7       3       0   proporz(votes, 10, \"hill-huntington\") #> Party A Party B Party C  #>       6       3       1   proporz(votes, 10, \"hill-huntington\", quorum = 0.05) #> Party A Party B Party C  #>       6       4       0   proporz(votes, 10, \"jefferson\", quorum = 70) #> Party A Party B Party C  #>       7       3       0"},{"path":"https://polettif.github.io/proporz/reference/proporz_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"List of method names and their implementation — proporz_methods","title":"List of method names and their implementation — proporz_methods","text":"Names can used proporz() biproporz(), list entries denote name implementation function.","code":""},{"path":"https://polettif.github.io/proporz/reference/proporz_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List of method names and their implementation — proporz_methods","text":"","code":"proporz_methods"},{"path":"https://polettif.github.io/proporz/reference/proporz_methods.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"List of method names and their implementation — proporz_methods","text":"object class list length 23.","code":""},{"path":"https://polettif.github.io/proporz/reference/proporz_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List of method names and their implementation — proporz_methods","text":"Named list methods","code":""},{"path":"https://polettif.github.io/proporz/reference/pukelsheim.html","id":null,"dir":"Reference","previous_headings":"","what":"Biproportional apportionment with data frames — pukelsheim","title":"Biproportional apportionment with data frames — pukelsheim","text":"Method proportionally allocate seats among parties/lists districts/regions/entities ('Doppelter Pukelsheim').","code":""},{"path":"https://polettif.github.io/proporz/reference/pukelsheim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Biproportional apportionment with data frames — pukelsheim","text":"","code":"pukelsheim(   votes_df,   district_seats_df,   quorum,   new_seats_col = \"seats\",   use_list_votes = TRUE,   winner_take_one = FALSE )"},{"path":"https://polettif.github.io/proporz/reference/pukelsheim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Biproportional apportionment with data frames — pukelsheim","text":"votes_df data.frame (long format) 3 columns (actual colnames can differ): party id/name district id/name votes district_seats_df data.frame 2 columns (actual colnames can differ): district id/name number seats district quorum Optional list functions take votes_matrix return logical vector denotes party/row whether reached quorum (.e. eligible seats). easiest way via quorum_any() quorum_all(), see examples. Alternatively can pass precalculated logical vector. quorum applied parameter missing NULL. new_seats_col name new column use_list_votes default (TRUE) assumed voter district many votes seats district. Set FALSE votes_df shows number voters (e.g. can vote one party). winner_take_one Set TRUE party got votes district must get least one seat ('Majorzbedingung') district. applies entitled seat upper apportionment. Default FALSE.","code":""},{"path":"https://polettif.github.io/proporz/reference/pukelsheim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Biproportional apportionment with data frames — pukelsheim","text":"data.frame like votes_df new column denoting number seats per party district. Party district divisors stored attributes attributes (hidden print, see get_divisors()).","code":""},{"path":"https://polettif.github.io/proporz/reference/pukelsheim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Biproportional apportionment with data frames — pukelsheim","text":"party nominates candidate list every district. voters vote parties district. seat allocation calculated two steps: called upper apportionment number seats party (districts) determined. called lower apportionment seats distributed regional party list respecting results upper apportionment. Parties failing reach quorums get seats. function handle seat assignment candidates. want use apportion methods Sainte-Laguë use biproporz().","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/pukelsheim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Biproportional apportionment with data frames — pukelsheim","text":"","code":"# Zug 2018 votes_df = unique(zug2018[c(\"list_id\", \"entity_id\", \"list_votes\")]) district_seats_df = unique(zug2018[c(\"entity_id\", \"election_mandates\")])  seats_df = pukelsheim(votes_df,                       district_seats_df,                       quorum_any(any_district = 0.05, total = 0.03),                       winner_take_one = TRUE)  head(seats_df) #>   list_id entity_id list_votes seats #> 1       2      1701       8108     2 #> 2       1      1701       2993     0 #> 3       3      1701      19389     3 #> 4       4      1701      14814     2 #> 5       5      1701       4486     1 #> 6       6      1701      15695     3  # Finland 2019 finland19_result = pukelsheim(finland2019$votes_df,                              finland2019$district_seats_df,                              new_seats_col = \"mandates\",                              use_list_votes = FALSE) tail(finland19_result[order(finland19_result$mandates),]) #>   party_name district_name  votes mandates #> 4         PS           UUS  86691        5 #> 5        KOK           HEL  84141        5 #> 7       VIHR           UUS  73626        5 #> 2        SDP           UUS  97107        6 #> 6       KESK           OUL  78486        6 #> 1        KOK           UUS 114243        7"},{"path":"https://polettif.github.io/proporz/reference/quorum_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Create quorum functions for biproportional apportionment — quorum_functions","title":"Create quorum functions for biproportional apportionment — quorum_functions","text":"quorum_any() quorum_all() used quorum parameter biproporz()/pukelsheim() help describe quorums applied prior seat distributions.","code":""},{"path":"https://polettif.github.io/proporz/reference/quorum_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create quorum functions for biproportional apportionment — quorum_functions","text":"","code":"quorum_all(any_district, total)  quorum_any(any_district, total)"},{"path":"https://polettif.github.io/proporz/reference/quorum_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create quorum functions for biproportional apportionment — quorum_functions","text":"any_district Vote threshold party must reach least one district. Used share total votes within district less 1 otherwise number votes. Must greater 0. Uses reached_quorum_any_district(). total Vote threshold party must reach votes cast. Used share total votes less 1. Otherwise number votes. Note votes weighted weight_list_votes() across districts. Must greater 0. Uses reached_quorum_total().","code":""},{"path":"https://polettif.github.io/proporz/reference/quorum_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create quorum functions for biproportional apportionment — quorum_functions","text":"function , called function(votes_matrix), returns boolean vector length equal number lists/parties (votes_matrix rows). vector shows whether party reached /quorums.","code":""},{"path":"https://polettif.github.io/proporz/reference/quorum_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create quorum functions for biproportional apportionment — quorum_functions","text":"difference functions work. quorum_any, least one quorum must reached. quorum_all (.e. ) quorums must reached. use one parameter, quorum_any() quorum_all() identical.","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/quorum_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create quorum functions for biproportional apportionment — quorum_functions","text":"","code":"votes_matrix = matrix(c(502, 55, 80, 10, 104, 55, 0, 1), ncol = 2) dimnames(votes_matrix) <- list(c(\"A\", \"B\", \"C\", \"D\"), c(\"Z1\", \"Z2\")) seats = c(Z1 = 50, Z2 = 20)  # use as parameter in biproporz or pukelsheim (general use case) biproporz(votes_matrix, seats,           quorum = quorum_any(any_district = 0.1, total = 100)) #>   Z1 Z2 #> A 40 12 #> B  5  8 #> C  5  0 #> D  0  0  biproporz(votes_matrix, seats,           quorum = quorum_all(any_district = 0.1, total = 100)) #>   Z1 Z2 #> A 44 12 #> B  6  8 #> C  0  0 #> D  0  0  biproporz(votes_matrix, seats, quorum = quorum_any(any_district = 0.1)) #>   Z1 Z2 #> A 40 12 #> B  5  8 #> C  5  0 #> D  0  0  biproporz(votes_matrix, seats, quorum = quorum_any(total = 100)) #>   Z1 Z2 #> A 44 12 #> B  6  8 #> C  0  0 #> D  0  0  biproporz(votes_matrix, seats, quorum = quorum_any(total = 0.5)) #>   Z1 Z2 #> A 50 20 #> B  0  0 #> C  0  0 #> D  0  0  # the quorum parameter also accepts vectors (e.g. calculated elsewhere) biproporz(votes_matrix, seats, quorum = c(FALSE, TRUE, TRUE, TRUE)) #>   Z1 Z2 #> A  0  0 #> B 27 20 #> C 20  0 #> D  3  0"},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_any_district.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if parties reached a quorum in at least one district — reached_quorum_any_district","title":"Check if parties reached a quorum in at least one district — reached_quorum_any_district","text":"Base implementation, used quorum_functions.","code":""},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_any_district.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if parties reached a quorum in at least one district — reached_quorum_any_district","text":"","code":"reached_quorum_any_district(votes_matrix, quorum_districts)"},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_any_district.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if parties reached a quorum in at least one district — reached_quorum_any_district","text":"votes_matrix votes matrix quorum_districts Vote threshold party must reach least one district. Used fraction total votes within district less 1, otherwise number votes. Must greater 0.","code":""},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_any_district.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if parties reached a quorum in at least one district — reached_quorum_any_district","text":"Logical vector length equal number lists/parties (votes_matrix rows) showing whether reached quorum .","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_any_district.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if parties reached a quorum in at least one district — reached_quorum_any_district","text":"","code":"(vm = matrix(c(239, 10, 308, 398, 20, 925), nrow = 3)) #>      [,1] [,2] #> [1,]  239  398 #> [2,]   10   20 #> [3,]  308  925 reached_quorum_any_district(vm, 25) #> [1]  TRUE FALSE  TRUE"},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_total.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if parties reached the quorum for all votes — reached_quorum_total","title":"Check if parties reached the quorum for all votes — reached_quorum_total","text":"Base implementation, used quorum_functions.","code":""},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_total.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if parties reached the quorum for all votes — reached_quorum_total","text":"","code":"reached_quorum_total(votes_matrix, quorum_total)"},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_total.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if parties reached the quorum for all votes — reached_quorum_total","text":"votes_matrix votes matrix quorum_total Vote threshold party must reach votes cast. Used fraction total votes less 1, otherwise number votes. Must greater 0.","code":""},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_total.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if parties reached the quorum for all votes — reached_quorum_total","text":"Logical vector length equal number lists/parties (votes_matrix rows) showing whether reached quorum .","code":""},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_total.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check if parties reached the quorum for all votes — reached_quorum_total","text":"Votes weighted across districts. relevant quorum threshold minimal number voters (either percentage absolute value). case, use weight_list_votes() calculating quorum.","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/reached_quorum_total.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if parties reached the quorum for all votes — reached_quorum_total","text":"","code":"(vm = matrix(c(239, 10, 308, 398, 20, 925), nrow = 3)) #>      [,1] [,2] #> [1,]  239  398 #> [2,]   10   20 #> [3,]  308  925 reached_quorum_total(vm, 35) #> [1]  TRUE FALSE  TRUE"},{"path":"https://polettif.github.io/proporz/reference/reached_quorums.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a list of quorum functions to a votes matrix — reached_quorums","title":"Apply a list of quorum functions to a votes matrix — reached_quorums","text":"Apply list quorum functions votes matrix","code":""},{"path":"https://polettif.github.io/proporz/reference/reached_quorums.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a list of quorum functions to a votes matrix — reached_quorums","text":"","code":"reached_quorums(votes_matrix, quorum_funcs)"},{"path":"https://polettif.github.io/proporz/reference/reached_quorums.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a list of quorum functions to a votes matrix — reached_quorums","text":"votes_matrix votes matrix quorum_funcs List quorum functions. list, attribute \"type\" must set indicates whether (.e. least one) quorum must reached. low-level implementation quorum calculations called within biproporz(). generally need call directly.","code":""},{"path":"https://polettif.github.io/proporz/reference/reached_quorums.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a list of quorum functions to a votes matrix — reached_quorums","text":"Logical vector length equal number lists/parties (votes_matrix rows) showing whether reached quorum .","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/run_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Use biproportional apportionment interactively in a shiny app — run_app","title":"Use biproportional apportionment interactively in a shiny app — run_app","text":"Use biproportional apportionment interactively shiny app","code":""},{"path":"https://polettif.github.io/proporz/reference/run_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use biproportional apportionment interactively in a shiny app — run_app","text":"","code":"run_app(votes_matrix = NULL, district_seats = NULL)"},{"path":"https://polettif.github.io/proporz/reference/run_app.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use biproportional apportionment interactively in a shiny app — run_app","text":"votes_matrix optional votes_matrix load upon start district_seats optional district_seats load upon start","code":""},{"path":"https://polettif.github.io/proporz/reference/run_app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use biproportional apportionment interactively in a shiny app — run_app","text":"Calling function starts shiny app","code":""},{"path":"https://polettif.github.io/proporz/reference/run_app.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use biproportional apportionment interactively in a shiny app — run_app","text":"","code":"if(interactive()){     # You need to have the packages 'shiny' and 'shinyMatrix' installed to run the app     run_app()      # It's possible to load a matrix with the app     run_app(uri2020$votes_matrix, uri2020$seats_vector) }"},{"path":"https://polettif.github.io/proporz/reference/upper_apportionment.html","id":null,"dir":"Reference","previous_headings":"","what":"Upper apportionment — upper_apportionment","title":"Upper apportionment — upper_apportionment","text":"first step biproportional apportionment parties given seats according sum votes across districts.","code":""},{"path":"https://polettif.github.io/proporz/reference/upper_apportionment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Upper apportionment — upper_apportionment","text":"","code":"upper_apportionment(   votes_matrix,   district_seats,   use_list_votes = TRUE,   method = \"round\" )"},{"path":"https://polettif.github.io/proporz/reference/upper_apportionment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Upper apportionment — upper_apportionment","text":"votes_matrix Vote count matrix votes party rows votes district columns. district_seats Vector defining number seats per district. Must length ncol(votes_matrix). Values name-matched votes_matrix columns named. number seats per district calculated according number votes (general use case), single number total number seats can used. use_list_votes default (TRUE) assumed voter district many votes seats district. Thus, votes weighted according number available district seats weight_list_votes(). Set FALSE votes_matrix shows number voters (.e. can cast one vote one party). method Apportion method defines seats assigned, see proporz(). Default Saintë-Lague/Webster method.","code":""},{"path":"https://polettif.github.io/proporz/reference/upper_apportionment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Upper apportionment — upper_apportionment","text":"named list district seats (votes_matrix columns) party seats (rows).","code":""},{"path":"https://polettif.github.io/proporz/reference/upper_apportionment.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Upper apportionment — upper_apportionment","text":"results upper apportionment define number seats party number seats district whole voting area. lower apportionment determine (.e. district) party seats allocated. Thus, upper apportionment done, final strength party/district within parliament definite.","code":""},{"path":[]},{"path":"https://polettif.github.io/proporz/reference/upper_apportionment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Upper apportionment — upper_apportionment","text":"","code":"votes_matrix = matrix(c(123,912,312,45,714,255,815,414,215), nrow = 3) district_seats = c(7,5,8)  upper_apportionment(votes_matrix, district_seats) #> $district #> [1] 7 5 8 #>  #> $party #> [1]  5 11  4 #>"},{"path":"https://polettif.github.io/proporz/reference/uri2020.html","id":null,"dir":"Reference","previous_headings":"","what":"Election Data for the Cantonal Council of Uri (2020) — uri2020","title":"Election Data for the Cantonal Council of Uri (2020) — uri2020","text":"Example election data 2020 election cantonal council Uri (Landrat) Switzerland. data extracted report \"Landratswahlen 2020: Statistische Auswertung\".","code":""},{"path":"https://polettif.github.io/proporz/reference/uri2020.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Election Data for the Cantonal Council of Uri (2020) — uri2020","text":"","code":"uri2020"},{"path":"https://polettif.github.io/proporz/reference/uri2020.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Election Data for the Cantonal Council of Uri (2020) — uri2020","text":"List containing: votes_matrix number votes party district (4 rows, 4 columns) seats_vector number seats per district (length 4)","code":""},{"path":"https://polettif.github.io/proporz/reference/uri2020.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Election Data for the Cantonal Council of Uri (2020) — uri2020","text":"https://www.ur.ch/abstimmungen/termine/9322","code":""},{"path":"https://polettif.github.io/proporz/reference/weight_list_votes.html","id":null,"dir":"Reference","previous_headings":"","what":"Create weighted votes matrix — weight_list_votes","title":"Create weighted votes matrix — weight_list_votes","text":"Weight list votes dividing votes matrix entries number seats per district. method used upper_apportionment() use_list_votes TRUE (default).","code":""},{"path":"https://polettif.github.io/proporz/reference/weight_list_votes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create weighted votes matrix — weight_list_votes","text":"","code":"weight_list_votes(votes_matrix, district_seats)"},{"path":"https://polettif.github.io/proporz/reference/weight_list_votes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create weighted votes matrix — weight_list_votes","text":"votes_matrix votes matrix district_seats seats per district, vector length ncol(votes_matrix)","code":""},{"path":"https://polettif.github.io/proporz/reference/weight_list_votes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create weighted votes matrix — weight_list_votes","text":"weighted votes_matrix","code":""},{"path":"https://polettif.github.io/proporz/reference/weight_list_votes.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create weighted votes matrix — weight_list_votes","text":"weighted votes rounded. Matrix vector names ignored.","code":""},{"path":"https://polettif.github.io/proporz/reference/weight_list_votes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create weighted votes matrix — weight_list_votes","text":"","code":"weight_list_votes(uri2020$votes_matrix, uri2020$seats_vector) #>       Altdorf  Bürglen Erstfeld Schattdorf #> CVP  764.7333 403.1429 384.8333   532.6667 #> SPGB 793.8667 229.4286 284.1667   288.8889 #> FDP  614.2000 223.8571 157.6667   329.0000 #> SVP  517.0667 420.7143 262.1667   388.6667"},{"path":"https://polettif.github.io/proporz/reference/zug2018.html","id":null,"dir":"Reference","previous_headings":"","what":"Election Data for the Cantonal Council of Zug (2018) — zug2018","title":"Election Data for the Cantonal Council of Zug (2018) — zug2018","text":"Example election data 2018 election cantonal council Zug (Kantonsrat) Switzerland.","code":""},{"path":"https://polettif.github.io/proporz/reference/zug2018.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Election Data for the Cantonal Council of Zug (2018) — zug2018","text":"","code":"zug2018"},{"path":"https://polettif.github.io/proporz/reference/zug2018.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Election Data for the Cantonal Council of Zug (2018) — zug2018","text":"object class data.frame 267 rows 49 columns.","code":""},{"path":"https://polettif.github.io/proporz/reference/zug2018.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Election Data for the Cantonal Council of Zug (2018) — zug2018","text":"Kanton Zug (01.07.2022, 10:27:58). Kantonsratswahl 2018 (CSV). https://wab.zug.ch/elections/kantonsratswahl-2018/data-csv","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-151","dir":"Changelog","previous_headings":"","what":"proporz 1.5.1","title":"proporz 1.5.1","text":"new “Modifying biproporz()” vignette (#15) add district_winner_matrix() function, exported internal implementation (#13) add apply_quorum() function, exported internal implementation add summary() method biproporz results shows marginal sums divisors returned seat values proporz/biproporz functions always integer undefined biproporz results caught earlier, added flow criterion check (#14) minor changes error messages","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-150","dir":"Changelog","previous_headings":"","what":"proporz 1.5.0","title":"proporz 1.5.0","text":"CRAN release: 2024-04-03 add new feature: winner take one method biproporz() pukelsheim() (#10) allow non-integer vote counts round divisors digits possible changed error message undefined/tied results fixed bugs added real data tests","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-140","dir":"Changelog","previous_headings":"","what":"proporz 1.4.0","title":"proporz 1.4.0","text":"CRAN release: 2024-03-04 first CRAN release add vignette examples removed biproportional(), use biproporz() renamed quota_largest_remainder() largest_remainder_method() renamed divisors() get_divisors() removed hzv() alias made reached_quorums() internal update documentation tests minor bugfixes","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-131","dir":"Changelog","previous_headings":"","what":"proporz 1.3.1","title":"proporz 1.3.1","text":"error enough seats available harmonic/geometric divisor methods always error equal remainders","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-130","dir":"Changelog","previous_headings":"","what":"proporz 1.3.0","title":"proporz 1.3.0","text":"rework expand quorum calculations (#4) deprecated quorum_total quorum_districts parameters","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-121","dir":"Changelog","previous_headings":"","what":"proporz 1.2.1","title":"proporz 1.2.1","text":"allow number seats 0 instead throwing error","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-120","dir":"Changelog","previous_headings":"","what":"proporz 1.2.0","title":"proporz 1.2.0","text":"throw error solution can found added basic shiny app","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-110","dir":"Changelog","previous_headings":"","what":"proporz 1.1.0","title":"proporz 1.1.0","text":"apportion method use_list_votes parameter biproportional() add finland2019 dataset export lower upper apportionment functions improve divisor search","code":""},{"path":"https://polettif.github.io/proporz/news/index.html","id":"proporz-100","dir":"Changelog","previous_headings":"","what":"proporz 1.0.0","title":"proporz 1.0.0","text":"Publish package Github","code":""}]
